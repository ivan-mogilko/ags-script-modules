
enum WindowEdge
{
    eWinEdgeNone, 
    eWinEdgeLeft, 
    eWinEdgeRight, 
    eWinEdgeTop, 
    eWinEdgeBottom, 
    eWinEdgeTopLeft, 
    eWinEdgeTopRight, 
    eWinEdgeBottomLeft, 
    eWinEdgeBottomRight 
};

enum DragWindowMode
{
    eDragWindow_Move = 1000, 
    eDragWindow_Resize = 1001, 
};

struct WindowsSystem
{
    int TopZ;
    int BorderWidth;
    int CaptionHeight;
    int NormalCursor;
    int DragCursor;
    int ResizeHorizontalCursor;
    int ResizeVerticalCursor;
    int ResizeTLBRCursor;
    int ResizeTRBLCursor;
    
    int WindowCount;
    int DraggingWindow;
    int ResizingWindow;
    WindowEdge ResizingWindowEdge;
    bool WasInterfaceEnabled;
    bool WasMouseButtonDown[4];
    
    import static readonly attribute bool IsWindowAction;
};

managed struct WindowInternal extends Window
{
    import void Init(int id);
    
    int FirstControlIndex;
};

managed struct WindowControlInternal
{
    int ID;
    int ParentID;
    // Layout ---
    WindowSide Anchor;
};

WindowsSystem g_winSystem;
// Array of Windows, index matches GUI ids
WindowInternal* g_windows[];
// Z-Sorted array of Windows, used for convenient reorder
Window* g_winStack[];
// A reference array that stores first control index per each GUI.
int g_winFirstControlIndex[];
// Array of extended controls data, associated with GUI controls.
// Because v3 AGS compiler does not support multidimensional arrays, 
// this is a flat list of all controls of all GUIs. Windows find their
// controls using first control index ref array.
WindowControlInternal* g_winControls[];

//===========================================================================
//
// UTILITIES
//
//===========================================================================

int Min(int a, int b)
{
    if (a < b)
        return a;
    return b;
}

int Max(int a, int b)
{
    if (a >= b)
        return a;
    return b;
}

int Clamp(int value, int min, int max)
{
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

//===========================================================================
//
// WINDOW SETTINGS
//
//===========================================================================

int Window::GetRealMinWidth()
{
    int min_width = 1;
    if (this.MinWidth > 0)
        min_width = this.MinWidth;
    return Max(min_width, g_winSystem.BorderWidth * 2 + this._padding[eWinSideLeft] + this._padding[eWinSideRight]);
}

int Window::GetRealMaxWidth()
{
    int max_width = 0x7FFFFFFF;
    if (this.MaxWidth > 0)
        max_width = this.MaxWidth;
    return Max(max_width, g_winSystem.BorderWidth * 2 + this._padding[eWinSideLeft] + this._padding[eWinSideRight]);
}

int Window::GetRealMinHeight()
{
    int min_height = 1;
    if (this.MinHeight > 0)
        min_height = this.MinHeight;
    return Max(min_height, g_winSystem.BorderWidth * 2 + this._padding[eWinSideTop] + this._padding[eWinSideBottom]);
}

int Window::GetRealMaxHeight()
{
    int max_height = 0x7FFFFFFF;
    if (this.MaxHeight > 0)
        max_height = this.MaxHeight;
    return Max(max_height, g_winSystem.BorderWidth * 2 + this._padding[eWinSideLeft] + this._padding[eWinSideRight]);
}

void SetWindowSize(int win_id, int width, int height)
{
    Window* window = g_windows[win_id];
    int max_width = window.GetRealMaxWidth();
    int max_height = window.GetRealMaxHeight();
    int min_width = window.GetRealMinWidth();
    int min_height = window.GetRealMinHeight();

    width = Clamp(width, min_width, max_width);
    height = Clamp(height, min_height, max_height);
    gui[win_id].SetSize(width, height);
}

void UpdateWindowSize(int win_id)
{
    SetWindowSize(win_id, gui[win_id].Width, gui[win_id].Height);
}

void SetWindowPosition(int win_id, int x, int y)
{
    gui[win_id].SetPosition(x, y);
}

void SetWindowPosition2(int win_id, int x, int y, int width, int height)
{
    gui[win_id].SetPosition(x, y);
    SetWindowSize(win_id, width, height);
}

WindowEdge GetWindowEdge(int win_id, int x, int y)
{
    GUI* g = gui[win_id];
    int gx = g.X;
    int gy = g.Y;
    int width = g.Width;
    int height = g.Height;
    
    WindowEdge edge = eWinEdgeNone;
    if (x <= g_winSystem.BorderWidth)
    {
        if (y <= g_winSystem.BorderWidth)
            return eWinEdgeTopLeft;
        else if (y >= height - g_winSystem.BorderWidth)
            return eWinEdgeBottomLeft;
        else
            return eWinEdgeLeft;
    }
    else if (x >= width - g_winSystem.BorderWidth)
    {
        if (y <= g_winSystem.BorderWidth)
            return eWinEdgeTopRight;
        else if (y >= height - g_winSystem.BorderWidth)
            return eWinEdgeBottomRight;
        else
            return eWinEdgeRight;
    }
    else if (y <= g_winSystem.BorderWidth)
    {
        return eWinEdgeTop;
    }
    else if (y >= height - g_winSystem.BorderWidth)
    {
        return eWinEdgeBottom;
    }
    else
    {
        return eWinEdgeNone;
    }
}

void ResetWindowDragState()
{
    g_winSystem.DraggingWindow = -1;
    g_winSystem.ResizingWindow = -1;
    g_winSystem.ResizingWindowEdge = eWinEdgeNone;
}

//===========================================================================
//
// WINDOW METHODS AND PROPERTIES
//
//===========================================================================

int get_ID(this Window*)
{
    return this._id;
}

bool get_HasFocus(this Window*)
{
    return this._hasFocus;
}

bool get_IsMoveable(this Window*)
{
    return (this._style & eWinStyleMoveable) != 0;
}

bool get_IsSizeable(this Window*)
{
    return (this._style & eWinStyleSizeable) != 0;
}

bool get_IsTopmost(this Window*)
{
    return (this._style & eWinStyleTopmost) != 0;
}

void SetZSortPos(this Window*, int pos)
{
    this._zsortPos = pos;
}

void UnsetFocus(this Window*)
{
    this._hasFocus = false;
}

void Window::MoveToTop()
{
    // If this is a topmost-style window, then use topmost order, 
    // but if this is a non-topmost style, then find the first slot
    // after existing topmost-style windows.
    int top_slot = 0;
    if (!this.get_IsTopmost())
    {
        for (int i = 0; i < Game.GUICount; i++)
        {
            if (g_winStack[i] == this)
            {
                continue;
            }
            
            if (g_winStack[i] != null && g_winStack[i].get_IsTopmost())
            {
                top_slot++;
            }
            else
            {
                break;
            }
        }
    }
    
    // Are we at the top already?
    if (g_winStack[top_slot] == this)
    {
        return;
    }
    
    // Remove ourselves from the stack
    if (this._zsortPos >= 0)
    {
        g_winStack[this._zsortPos] = null;
    }
    
    Window* new_window = this;
    do
    {
        Window* was_window = g_winStack[top_slot];
        g_winStack[top_slot] = new_window;
        new_window.SetZSortPos(top_slot);
        gui[new_window.get_ID()].ZOrder = g_winSystem.TopZ - top_slot;
        new_window = was_window;
        top_slot++;
    }
    while (new_window != null);
}

void Window::UpdateLayout()
{
    if (!this._enableLayout)
        return;
    
    GUI* g = gui[this._id];
    int right_diff = g.Width - this._lastLayoutWidth;
    int bottom_diff = g.Height - this._lastLayoutHeight;
    
    int pad_left = g_winSystem.BorderWidth + this._padding[eWinSideLeft];
    int pad_right = g.Width - g_winSystem.BorderWidth - this._padding[eWinSideRight] + 1;
    int pad_top = g_winSystem.BorderWidth + this._padding[eWinSideTop];
    int pad_bottom = g.Height - g_winSystem.BorderWidth - this._padding[eWinSideBottom] + 1;
    
    for (int i = 0; i < g.ControlCount; i++)
    {
        GUIControl* g_ctrl = g.Controls[i];
        WindowControlInternal* w_ctrl = g_winControls[g_winFirstControlIndex[this._id] + i];
        int anchor = w_ctrl.Anchor;
        
        int xleft = g_ctrl.X;
        int xright = g_ctrl.X + g_ctrl.Width;
        int ytop = g_ctrl.Y;
        int ybottom = g_ctrl.Y + g_ctrl.Height;
        
        if ((anchor & eWinAnchorRight) != 0)
        {
            xright += right_diff;
            // move left side only if not anchored to parent's left
            if ((anchor & eWinAnchorLeft) == 0)
                xleft += right_diff;
        }
        
        if ((anchor & eWinAnchorBottom) != 0)
        {
            ybottom += bottom_diff;
            // move top side only if not anchored to parent's top
            if ((anchor & eWinAnchorTop) == 0)
                ytop += bottom_diff;
        }
        
        // Only use padding when control is anchored at the respective side
        int minleft = xleft;
        int maxright = xright;
        int mintop = ytop;
        int maxbottom = ybottom;
        if ((anchor & eWinAnchorLeft) != 0)
            minleft = pad_left;
        if ((anchor & eWinAnchorRight) != 0)
            maxright = pad_right;
        if ((anchor & eWinAnchorTop) != 0)
            mintop = pad_top;
        if ((anchor & eWinAnchorBottom) != 0)
            maxbottom = pad_bottom;
        
        xleft = Clamp(xleft, minleft, maxright);
        xright = Max(xleft + 1, Clamp(xright, minleft, maxright));
        ytop = Clamp(ytop, mintop, maxbottom);
        ybottom = Max(ytop + 1, Clamp(ybottom, mintop, maxbottom));
        
        g_ctrl.X = xleft;
        g_ctrl.Width = xright - xleft;
        g_ctrl.Y = ytop;
        g_ctrl.Height = ybottom - ytop;
    }
    
    this._lastLayoutWidth = g.Width;
    this._lastLayoutHeight = g.Height;
}

WindowStyle get_Style(this Window*)
{
    return this._style;
}

void set_Style(this Window*, WindowStyle style)
{
    this._style = style;
    
    // Cancel any ongoing actions that are not suitable for this window style
    if ((g_winSystem.DraggingWindow == this._id) && ((style & eWinStyleMoveable) == 0) ||
        (g_winSystem.ResizingWindow == this._id) && ((style & eWinStyleSizeable) == 0))
    {
        DragDrop.Revert();
        ResetWindowDragState();
    }
    
    if ((style & eWinStyleTopmost) != 0)
    {
        this.MoveToTop();
    }
}

int get_MinWidth(this Window*)
{
    return this._minWidth;
}

void set_MinWidth(this Window*, int min_width)
{
    if (min_width > 0 && this._maxWidth > 0)
        this._maxWidth = Max(this._maxWidth, min_width);
    this._minWidth = min_width;
    UpdateWindowSize(this._id);
    this.UpdateLayout();
}

int get_MaxWidth(this Window*)
{
    return this._maxWidth;
}

void set_MaxWidth(this Window*, int max_width)
{
    if (max_width > 0 && this._minWidth > 0)
        this._minWidth = Min(this._minWidth, max_width);
    this._maxWidth = max_width;
    UpdateWindowSize(this._id);
    this.UpdateLayout();
}

int get_MinHeight(this Window*)
{
    return this._minHeight;
}

void set_MinHeight(this Window*, int min_height)
{
    if (min_height > 0 && this._maxHeight > 0)
        this._maxHeight = Max(this._maxHeight, min_height);
    this._minHeight = min_height;
    UpdateWindowSize(this._id);
    this.UpdateLayout();
}

int get_MaxHeight(this Window*)
{
    return this._maxHeight;
}

void set_MaxHeight(this Window*, int max_height)
{
    if (max_height > 0 && this._minHeight > 0)
        this._minHeight = Min(this._minHeight, max_height);
    this._maxHeight = max_height;
    UpdateWindowSize(this._id);
    this.UpdateLayout();
}

int geti_Padding(this Window*, int side)
{
    if (side >= 0 && side < 4)
        return this._padding[side];
    return -1;
}

void seti_Padding(this Window*, int side, int padding)
{
    if (side >= 0 && side < 4)
    {
        this._padding[side] = padding;
        this.UpdateLayout();
    }
}

void Window::Focus()
{
    for (int i = 0; i < Game.GUICount; i++)
    {
        if (g_windows[i] != null)
        {
            g_windows[i].UnsetFocus();
        }
    }
    
    this._hasFocus = true;
    this.MoveToTop();
}

void WindowInternal::Init(int id)
{
    this._id = id;
    this._zsortPos = -1;
    
    GUI* g = gui[this._id];
    this._lastLayoutWidth = g.Width;
    this._lastLayoutHeight = g.Height;
}

void EnableLayout(this Window*, bool enable)
{
    this._enableLayout = enable;
    if (enable)
        this.UpdateLayout();
}

//===========================================================================
//
// WINDOW ACTIONS
//
//===========================================================================

void BeginResize(int win_id, int x, int y)
{
    ResetWindowDragState();
    
    GUI* g = gui[win_id];
    int gx = g.X;
    int gy = g.Y;
    int width = g.Width;
    int height = g.Height;
    
    WindowEdge edge = GetWindowEdge(win_id, x, y);
    if (edge == eWinEdgeNone)
    {
        return;
    }
    
    // The dragged pseudo-object position will be a position of a respective window edge or corner
    int dobj_x, dobj_y;
    switch (edge)
    {
    case eWinEdgeLeft:
    case eWinEdgeTopLeft:
    case eWinEdgeBottomLeft:
        dobj_x = gx;
        break;
    case eWinEdgeRight:
    case eWinEdgeTopRight:
    case eWinEdgeBottomRight:
        dobj_x = gx + width - 1;
        break;
    }
    
    switch (edge)
    {
    case eWinEdgeTop:
    case eWinEdgeTopLeft:
    case eWinEdgeTopRight:
        dobj_y = gy;
        break;
    case eWinEdgeBottom:
    case eWinEdgeBottomLeft:
    case eWinEdgeBottomRight:
        dobj_y = gy + height - 1;
        break;
    }
    
    g_winSystem.ResizingWindow = win_id;
    g_winSystem.ResizingWindowEdge = edge;
    DragDrop.HookObject(eDragWindow_Resize, dobj_x, dobj_y);
}

void BeginMove(int win_id, int x, int y)
{
    ResetWindowDragState();
    
    g_winSystem.DraggingWindow = win_id;
    DragDrop.HookObject(eDragWindow_Move, gui[win_id].X, gui[win_id].Y);
}

void DoMove()
{
    GUI* g = gui[g_winSystem.DraggingWindow];
    g.SetPosition(DragDrop.ObjectX, DragDrop.ObjectY);
}

void DoResize()
{
    GUI* g = gui[g_winSystem.ResizingWindow];
    Window* w = g_windows[g_winSystem.ResizingWindow];
    int x = g.X;
    int y = g.Y;
    int width = g.Width;
    int height = g.Height;
    WindowEdge edge = g_winSystem.ResizingWindowEdge;
    int left_edge = x;
    int right_edge = x + width - 1;
    int top_edge = y;
    int bottom_edge = y + height - 1;
    int drag_x = DragDrop.ObjectX;
    int drag_y = DragDrop.ObjectY;
    
    // First get the projected size difference, clamped to the window limits
    int h_diff, v_diff;
    switch (edge)
    {
    case eWinEdgeLeft:
    case eWinEdgeTopLeft:
    case eWinEdgeBottomLeft:
        h_diff = left_edge - drag_x;
        break;
    case eWinEdgeRight:
    case eWinEdgeTopRight:
    case eWinEdgeBottomRight:
        h_diff = drag_x - right_edge;
        break;
    case eWinEdgeTop:
    case eWinEdgeTopLeft:
    case eWinEdgeTopRight:
        v_diff = top_edge - drag_y;
        break;
    case eWinEdgeBottom:
    case eWinEdgeBottomLeft:
    case eWinEdgeBottomRight:
        v_diff = drag_y - bottom_edge;
        break;
    }
    
    if (h_diff != 0)
    {
        int min_width = w.GetRealMinWidth();
        int max_width = w.GetRealMaxWidth();
        if (width + h_diff > max_width)
        {
            h_diff = max_width - width;
        }
        else if (width + h_diff < min_width)
        {
            h_diff = width - min_width;
        }
    }
    
    if (v_diff != 0)
    {
        int min_height = w.GetRealMinHeight();
        int max_height = w.GetRealMaxHeight();
        if (height + v_diff > max_height)
        {
            v_diff = max_height - height;
        }
        else if (height + v_diff < min_height)
        {
            v_diff = height - min_height;
        }
    }
    
    // Now apply the final difference, and also adjust the drag pos
    // in case the difference was restricted to a limit
    switch (edge)
    {
    case eWinEdgeLeft:
    case eWinEdgeTopLeft:
    case eWinEdgeBottomLeft:
        left_edge = left_edge - h_diff;
        x = left_edge;
        width += h_diff;
        drag_x = left_edge;
        break;
    case eWinEdgeRight:
    case eWinEdgeTopRight:
    case eWinEdgeBottomRight:
        right_edge = right_edge + h_diff;
        width = right_edge - left_edge + 1;
        drag_x = right_edge;
        break;
    }
    
    switch (edge)
    {
    case eWinEdgeTop:
    case eWinEdgeTopLeft:
    case eWinEdgeTopRight:
        top_edge = top_edge - v_diff;
        y = top_edge;
        height += v_diff;
        drag_y = top_edge;
        break;
    case eWinEdgeBottom:
    case eWinEdgeBottomLeft:
    case eWinEdgeBottomRight:
        bottom_edge = bottom_edge + v_diff;
        height = bottom_edge - top_edge + 1;
        drag_y = bottom_edge;
        break;
    }

    if (drag_x != DragDrop.ObjectX)
    {
        Mouse.SetPosition(drag_x + DragDrop.ObjectHandleX, mouse.y);
    }
    else if (drag_y != DragDrop.ObjectY)
    {
        Mouse.SetPosition(mouse.x, drag_y + DragDrop.ObjectHandleY);
    }

    SetWindowPosition2(g_winSystem.ResizingWindow, x, y, width, height);
    g_windows[g_winSystem.ResizingWindow].UpdateLayout();
}

void SetCursorForWindowEdge(WindowEdge edge)
{
    int cursor = g_winSystem.NormalCursor;
    switch (edge)
    {
    case eWinEdgeLeft:
    case eWinEdgeRight:
        cursor = g_winSystem.ResizeHorizontalCursor;
        break;
    case eWinEdgeTop:
    case eWinEdgeBottom:
        cursor = g_winSystem.ResizeVerticalCursor;
        break;
    case eWinEdgeTopLeft:
    case eWinEdgeBottomRight:
        cursor = g_winSystem.ResizeTLBRCursor;
        break;
    case eWinEdgeTopRight:
    case eWinEdgeBottomLeft:
        cursor = g_winSystem.ResizeTRBLCursor;
        break;
    }
    
    Mouse.Mode = cursor;
}

void SetCursorOverWindowEdge(int win_id, int x, int y)
{
    SetCursorForWindowEdge(GetWindowEdge(win_id, x, y));
}

//===========================================================================
//
// WINDOWS SYSTEM
//
//===========================================================================

int get_WindowCount(static Windows)
{
    return g_winSystem.WindowCount;
}

static Window*[] Windows::GetWindows()
{
    Window* wnd[] = new Window[g_winSystem.WindowCount];
    int wnd_idx;
    for (int i = 0; i < Game.GUICount; i++)
    {
        if (g_windows[i] != null)
        {
            wnd[wnd_idx] = g_windows[i];
            wnd_idx++;
        }
    }
    return wnd;
}

static void Windows::UpdateAllWindowLayouts()
{
    for (int i = 0; i < Game.GUICount; i++)
    {
        if (g_windows[i] != null)
        {
            g_windows[i].UpdateLayout();
        }
    }
}

bool get_IsWindowAction(static WindowsSystem)
{
    return g_winSystem.DraggingWindow >= 0 ||
        g_winSystem.ResizingWindow >= 0;
}

int get_TopZOrder(static Windows)
{
    return g_winSystem.TopZ;
}

void set_TopZOrder(static Windows, int top_z)
{
    g_winSystem.TopZ = top_z;
    // TODO: rearrange windows
}

int get_BorderWidth(static Windows)
{
    return g_winSystem.BorderWidth;
}

void set_BorderWidth(static Windows, int border_width)
{
    g_winSystem.BorderWidth = border_width;
}

int get_CaptionHeight(static Windows)
{
    return g_winSystem.CaptionHeight;
}

void set_CaptionHeight(static Windows, int caption_height)
{
    g_winSystem.CaptionHeight = caption_height;
}

int get_NormalCursor(static Windows)
{
    return g_winSystem.NormalCursor;
}

void set_NormalCursor(static Windows, int cursor)
{
    g_winSystem.NormalCursor = cursor;
    // TODO: adjust action in progress
}

int get_DragCursor(static Windows)
{
    return g_winSystem.DragCursor;
}

void set_DragCursor(static Windows, int cursor)
{
    g_winSystem.DragCursor = cursor;
    // TODO: adjust action in progress
}

int get_ResizeHorizontalCursor(static Windows)
{
    return g_winSystem.ResizeHorizontalCursor;
}

void set_ResizeHorizontalCursor(static Windows, int cursor)
{
    g_winSystem.ResizeHorizontalCursor = cursor;
    // TODO: adjust action in progress
}

int get_ResizeVerticalCursor(static Windows)
{
    return g_winSystem.ResizeVerticalCursor;
}

void set_ResizeVerticalCursor(static Windows, int cursor)
{
    g_winSystem.ResizeVerticalCursor = cursor;
    // TODO: adjust action in progress
}

int get_ResizeTLBRCursor(static Windows)
{
    return g_winSystem.ResizeTLBRCursor;
}

void set_ResizeTLBRCursor(static Windows, int cursor)
{
    g_winSystem.ResizeTLBRCursor = cursor;
    // TODO: adjust action in progress
}

int get_ResizeTRBLCursor(static Windows)
{
    return g_winSystem.ResizeTRBLCursor;
}

void set_ResizeTRBLCursor(static Windows, int cursor)
{
    g_winSystem.ResizeTRBLCursor = cursor;
    // TODO: adjust action in progress
}

//===========================================================================
//
// WINDOW GUI EXTENDERS
//
//===========================================================================

void AddToWindows(this GUI*, WindowStyle style)
{
    if (g_windows[this.ID] != null)
    {
        return;
    }
    
    g_windows[this.ID] = new WindowInternal;
    WindowInternal* window = g_windows[this.ID];
    window.Init(this.ID);
    window.EnableLayout(false);
    window.Style = style;
    window.MaxWidth = -1;
    window.MaxHeight = -1;
    window.MinWidth = -1;
    window.MinHeight = -1;
    g_winSystem.WindowCount++;
    
    // Add controls to our system
    for (int i = 0; i < this.ControlCount; i++)
    {
        int base_index = g_winFirstControlIndex[this.ID];
        WindowControlInternal* win_ctrl = new WindowControlInternal;
        win_ctrl.ID = i;
        win_ctrl.ParentID = this.ID;
        win_ctrl.Anchor = eWinAnchorLeft | eWinAnchorTop;
        g_winControls[base_index + i] = win_ctrl;
    }
    
    window.EnableLayout(true);
    // New windows appear on top
    window.MoveToTop();
}

void RemoveFromWindows(this GUI*)
{
    if (g_windows[this.ID] == null)
    {
        return;
    }
    
    // Cancel any actions regarding this window
    if (g_winSystem.IsWindowAction)
    {
        DragDrop.Revert();
        ResetWindowDragState();
    }
    
    g_winSystem.WindowCount--;
    g_windows[this.ID] = null;
    
    // Remove controls from our system
    for (int i = 0; i < gui[i].ControlCount; i++)
    {
        int base_index = g_winFirstControlIndex[this.ID];
        g_winControls[base_index + i] = null;
    }
}

Window* GetWindow(this GUI*)
{
    return g_windows[this.ID];
}

//===========================================================================
//
// WINDOW GUI CONTROL EXTENDERS
//
//===========================================================================

int GetWinControlIndex(this GUIControl*)
{
    int parent_id = this.OwningGUI.ID;
    if (g_windows[parent_id] == null)
        return -1;
    
    int base_id = g_winFirstControlIndex[parent_id];
    return base_id + this.ID;
}

void SetAnchor(this GUIControl*, WindowAnchor anchor)
{
    int control_id = this.GetWinControlIndex();
    if (control_id < 0)
        return;

    g_winControls[control_id].Anchor = anchor;
    g_windows[this.OwningGUI.ID].UpdateLayout();
}

//===========================================================================
//
// GENERAL EVENTS
//
//===========================================================================

function game_start()
{
    g_windows = new WindowInternal[Game.GUICount];
    g_winStack = new Window[Game.GUICount];
    g_winFirstControlIndex = new int[Game.GUICount];
    
    int total_control_count;
    for (int i = 0; i < Game.GUICount; i++)
    {
        g_winFirstControlIndex[i] = total_control_count;
        total_control_count += gui[i].ControlCount;
    }
    g_winControls = new WindowControlInternal[total_control_count];
    
    // Default system setup
    g_winSystem.BorderWidth = 1;
    g_winSystem.CaptionHeight = 10;
    // Place windows behind "normal" guis by default
    g_winSystem.TopZ = -1000;
    g_winSystem.DraggingWindow = -1;
    g_winSystem.ResizingWindow = -1;
    
    DragDrop.Enabled = true;
    DragDrop.DefaultHookMouseButton = eMouseLeft;
    DragDrop.AutoTrackHookKey = true;
    DragDrop.DefaultUnhookAction = eDDUnhookDrop;
}

function late_repeatedly_execute_always()
{
    // Don't do anything when interface is disabled
    if (!IsInterfaceEnabled())
    {
        if (g_winSystem.WasInterfaceEnabled)
        {
            if (!DragDrop.IsIdle)
                DragDrop.Revert();
            ResetWindowDragState();
        }
        g_winSystem.WasInterfaceEnabled = false;
        return;
    }
    
    GUI* on_gui = GUI.GetAtScreenXY(mouse.x, mouse.y);
    Window *on_window;
    if (on_gui != null)
        on_window = g_windows[on_gui.ID];

    bool on_window_border, on_window_caption;
    if (on_window != null)
    {
        int x = mouse.x - on_gui.X;
        int y = mouse.y - on_gui.Y;
        if (x <= g_winSystem.BorderWidth || x >= on_gui.Width - g_winSystem.BorderWidth
            || y <= g_winSystem.BorderWidth || y >= on_gui.Height - g_winSystem.BorderWidth)
        {
            on_window_border = true;
            
        }
        else if (x > g_winSystem.BorderWidth && x < on_gui.Width - g_winSystem.BorderWidth
            && y > g_winSystem.BorderWidth && y < g_winSystem.BorderWidth + g_winSystem.CaptionHeight)
        {
            on_window_caption = true;
        }
    }
    
    // Test window activation
    bool mousedown[4];
    mousedown[eMouseLeft] = mouse.IsButtonDown(eMouseLeft);
    mousedown[eMouseRight] = mouse.IsButtonDown(eMouseRight);
    mousedown[eMouseMiddle] = mouse.IsButtonDown(eMouseMiddle);
    if (mousedown[eMouseLeft] && !g_winSystem.WasMouseButtonDown[eMouseLeft] ||
        mousedown[eMouseRight] && !g_winSystem.WasMouseButtonDown[eMouseRight] ||
        mousedown[eMouseMiddle] && !g_winSystem.WasMouseButtonDown[eMouseMiddle])
    {
        if (on_window != null && !on_window.get_HasFocus() &&
            !g_winSystem.IsWindowAction)
        {
            on_window.Focus();
        }
    }
    
    // If player is trying to drag something: check for a window under cursor
    // and decide whether to move or resize, depending on which part is being
    // interacted with.
    if (DragDrop.EvtWantObject)
    {
        if (on_window != null)
        {
            int x = mouse.x - on_gui.X;
            int y = mouse.y - on_gui.Y;
            if (on_window_border)
            {
                BeginResize(on_gui.ID, x, y);
            }
            else if (on_window_caption)
            {
                BeginMove(on_gui.ID, x, y);
            }
        }
    }
    
    // While player is dragging: update the current drag state
    if (DragDrop.HasObjectHooked)
    {
        if (g_winSystem.DraggingWindow >= 0)
        {
            DoMove();
        }
        else if (g_winSystem.ResizingWindow >= 0)
        {
            DoResize();
        }
    }
    
    if (DragDrop.EvtDropped || DragDrop.EvtCancelled)
    {
        ResetWindowDragState();
    }
    
    // Update cursor graphic
    if (DragDrop.HasObjectHooked)
    {
        if (g_winSystem.DraggingWindow >= 0)
        {
            Mouse.Mode = g_winSystem.DragCursor;
        }
        else if (g_winSystem.ResizingWindow >= 0)
        {
            SetCursorForWindowEdge(g_winSystem.ResizingWindowEdge);
        }
    }
    else
    {
        if (on_window_border)
        {
            SetCursorOverWindowEdge(on_gui.ID, mouse.x - on_gui.X, mouse.y - on_gui.Y);
        }
        else
        {
            Mouse.Mode = g_winSystem.NormalCursor;
        }
    }
    
    // Record current states
    g_winSystem.WasInterfaceEnabled = true;
    g_winSystem.WasMouseButtonDown[eMouseLeft] = mousedown[eMouseLeft];
    g_winSystem.WasMouseButtonDown[eMouseRight] = mousedown[eMouseRight];
    g_winSystem.WasMouseButtonDown[eMouseMiddle] = mousedown[eMouseMiddle];
}
