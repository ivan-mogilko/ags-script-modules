
enum WindowEdge
{
    eWinEdgeNone, 
    eWinEdgeLeft, 
    eWinEdgeRight, 
    eWinEdgeTop, 
    eWinEdgeBottom, 
    eWinEdgeTopLeft, 
    eWinEdgeTopRight, 
    eWinEdgeBottomLeft, 
    eWinEdgeBottomRight 
};

enum DragWindowMode
{
    eDragWindow_Move = 1000, 
    eDragWindow_Resize = 1001, 
};

struct WindowsSystem
{
    int TopZ;
    int BorderWidth;
    int CaptionHeight;
    int NormalCursor;
    int DragCursor;
    int ResizeHorizontalCursor;
    int ResizeVerticalCursor;
    int ResizeDiagonalCursor;
    
    int WindowCount;
    int DraggingWindow;
    int ResizingWindow;
    WindowEdge ResizingWindowEdge;
    bool WasInterfaceEnabled;
    bool WasMouseButtonDown[4];
    
    import static readonly attribute bool IsWindowAction;
};

managed struct WindowInternal extends Window
{
    import void Init(int id);
};

WindowsSystem g_winSystem;
// Array of Windows, index matches GUI ids
WindowInternal* g_windows[];
// Z-Sorted array of Windows, used for convenient reorder
Window* g_winStack[];

//===========================================================================
//
// UTILITIES
//
//===========================================================================

int Min(int a, int b)
{
    if (a < b)
        return a;
    return b;
}

int Max(int a, int b)
{
    if (a >= b)
        return a;
    return b;
}

int Clamp(int value, int min, int max)
{
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

//===========================================================================
//
// WINDOWS SYSTEM
//
//===========================================================================

int get_WindowCount(static Windows)
{
    return g_winSystem.WindowCount;
}

static Window*[] Windows::GetWindows()
{
    Window* wnd[] = new Window[g_winSystem.WindowCount];
    int wnd_idx;
    for (int i = 0; i < Game.GUICount; i++)
    {
        if (g_windows[i] != null)
        {
            wnd[wnd_idx] = g_windows[i];
            wnd_idx++;
        }
    }
    return wnd;
}

bool get_IsWindowAction(static WindowsSystem)
{
    return g_winSystem.DraggingWindow >= 0 ||
        g_winSystem.ResizingWindow >= 0;
}

int get_TopZOrder(static Windows)
{
    return g_winSystem.TopZ;
}

void set_TopZOrder(static Windows, int top_z)
{
    g_winSystem.TopZ = top_z;
    // TODO: rearrange windows
}

int get_BorderWidth(static Windows)
{
    return g_winSystem.BorderWidth;
}

void set_BorderWidth(static Windows, int border_width)
{
    g_winSystem.BorderWidth = border_width;
}

int get_CaptionHeight(static Windows)
{
    return g_winSystem.CaptionHeight;
}

void set_CaptionHeight(static Windows, int caption_height)
{
    g_winSystem.CaptionHeight = caption_height;
}

int get_NormalCursor(static Windows)
{
    return g_winSystem.NormalCursor;
}

void set_NormalCursor(static Windows, int cursor)
{
    g_winSystem.NormalCursor = cursor;
    // TODO: adjust action in progress
}

int get_DragCursor(static Windows)
{
    return g_winSystem.DragCursor;
}

void set_DragCursor(static Windows, int cursor)
{
    g_winSystem.DragCursor = cursor;
    // TODO: adjust action in progress
}

int get_ResizeHorizontalCursor(static Windows)
{
    return g_winSystem.ResizeHorizontalCursor;
}

void set_ResizeHorizontalCursor(static Windows, int cursor)
{
    g_winSystem.ResizeHorizontalCursor = cursor;
    // TODO: adjust action in progress
}

int get_ResizeVerticalCursor(static Windows)
{
    return g_winSystem.ResizeVerticalCursor;
}

void set_ResizeVerticalCursor(static Windows, int cursor)
{
    g_winSystem.ResizeVerticalCursor = cursor;
    // TODO: adjust action in progress
}

int get_ResizeDiagonalCursor(static Windows)
{
    return g_winSystem.ResizeDiagonalCursor;
}

void set_ResizeDiagonalCursor(static Windows, int cursor)
{
    g_winSystem.ResizeDiagonalCursor = cursor;
    // TODO: adjust action in progress
}

//===========================================================================
//
// WINDOW SETTINGS
//
//===========================================================================

void SetWindowSize(int win_id, int width, int height)
{
    Window* window = g_windows[win_id];
    int max_width = width, max_height = height;
    int min_width = 1, min_height = 1;
    if (window.MaxWidth > 0)
        max_width = window.MaxWidth;
    if (window.MaxHeight > 0)
        max_height = window.MaxHeight;
    if (window.MinWidth > 0)
        min_width = window.MinWidth;
    if (window.MinHeight > 0)
        min_height = window.MinHeight;

    width = Clamp(width, min_width, max_width);
    height = Clamp(height, min_height, max_height);
    gui[win_id].SetSize(width, height);
}

void UpdateWindowSize(int win_id)
{
    SetWindowSize(win_id, gui[win_id].Width, gui[win_id].Height);
}

void SetWindowPosition(int win_id, int x, int y)
{
    gui[win_id].SetPosition(x, y);
}

void SetWindowPosition2(int win_id, int x, int y, int width, int height)
{
    gui[win_id].SetPosition(x, y);
    SetWindowSize(win_id, width, height);
}

WindowEdge GetWindowEdge(int win_id, int x, int y)
{
    GUI* g = gui[win_id];
    int gx = g.X;
    int gy = g.Y;
    int width = g.Width;
    int height = g.Height;
    
    WindowEdge edge = eWinEdgeNone;
    if (x <= g_winSystem.BorderWidth)
    {
        if (y <= g_winSystem.BorderWidth)
            return eWinEdgeTopLeft;
        else if (y >= height - g_winSystem.BorderWidth)
            return eWinEdgeBottomLeft;
        else
            return eWinEdgeLeft;
    }
    else if (x >= width - g_winSystem.BorderWidth)
    {
        if (y <= g_winSystem.BorderWidth)
            return eWinEdgeTopRight;
        else if (y >= height - g_winSystem.BorderWidth)
            return eWinEdgeBottomRight;
        else
            return eWinEdgeRight;
    }
    else if (y <= g_winSystem.BorderWidth)
    {
        return eWinEdgeTop;
    }
    else if (y >= height - g_winSystem.BorderWidth)
    {
        return eWinEdgeBottom;
    }
    else
    {
        return eWinEdgeNone;
    }
}

void ResetWindowDragState()
{
    g_winSystem.DraggingWindow = -1;
    g_winSystem.ResizingWindow = -1;
    g_winSystem.ResizingWindowEdge = eWinEdgeNone;
}

//===========================================================================
//
// WINDOW METHODS AND PROPERTIES
//
//===========================================================================

int get_ID(this Window*)
{
    return this._id;
}

bool get_HasFocus(this Window*)
{
    return this._hasFocus;
}

bool get_IsMoveable(this Window*)
{
    return (this._style & eWinStyleMoveable) != 0;
}

bool get_IsSizeable(this Window*)
{
    return (this._style & eWinStyleSizeable) != 0;
}

bool get_IsTopmost(this Window*)
{
    return (this._style & eWinStyleTopmost) != 0;
}

void SetZSortPos(this Window*, int pos)
{
    this._zsortPos = pos;
}

void UnsetFocus(this Window*)
{
    this._hasFocus = false;
}

void Window::MoveToTop()
{
    // If this is a topmost-style window, then use topmost order, 
    // but if this is a non-topmost style, then find the first slot
    // after existing topmost-style windows.
    int top_slot = 0;
    if (!this.get_IsTopmost())
    {
        for (int i = 0; i < Game.GUICount; i++)
        {
            if (g_winStack[i] == this)
            {
                continue;
            }
            
            if (g_winStack[i] != null && g_winStack[i].get_IsTopmost())
            {
                top_slot++;
            }
            else
            {
                break;
            }
        }
    }
    
    // Are we at the top already?
    if (g_winStack[top_slot] == this)
    {
        return;
    }
    
    // Remove ourselves from the stack
    if (this._zsortPos >= 0)
    {
        g_winStack[this._zsortPos] = null;
    }
    
    Window* new_window = this;
    do
    {
        Window* was_window = g_winStack[top_slot];
        g_winStack[top_slot] = new_window;
        new_window.SetZSortPos(top_slot);
        gui[new_window.get_ID()].ZOrder = g_winSystem.TopZ - top_slot;
        new_window = was_window;
        top_slot++;
    }
    while (new_window != null);
}

WindowStyle get_Style(this Window*)
{
    return this._style;
}

void set_Style(this Window*, WindowStyle style)
{
    this._style = style;
    
    // Cancel any ongoing actions that are not suitable for this window style
    if ((g_winSystem.DraggingWindow == this._id) && ((style & eWinStyleMoveable) == 0) ||
        (g_winSystem.ResizingWindow == this._id) && ((style & eWinStyleSizeable) == 0))
    {
        DragDrop.Revert();
        ResetWindowDragState();
    }
    
    if ((style & eWinStyleTopmost) != 0)
    {
        this.MoveToTop();
    }
}

int get_MinWidth(this Window*)
{
    return this._minWidth;
}

void set_MinWidth(this Window*, int min_width)
{
    if (min_width > 0 && this._maxWidth > 0)
        this._maxWidth = Max(this._maxWidth, min_width);
    this._minWidth = min_width;
    UpdateWindowSize(this._id);
}

int get_MaxWidth(this Window*)
{
    return this._maxWidth;
}

void set_MaxWidth(this Window*, int max_width)
{
    if (max_width > 0 && this._minWidth > 0)
        this._minWidth = Min(this._minWidth, max_width);
    this._maxWidth = max_width;
    UpdateWindowSize(this._id);
}

int get_MinHeight(this Window*)
{
    return this._minHeight;
}

void set_MinHeight(this Window*, int min_height)
{
    if (min_height > 0 && this._maxHeight > 0)
        this._maxHeight = Max(this._maxHeight, min_height);
    this._maxHeight = min_height;
    UpdateWindowSize(this._id);
}

int get_MaxHeight(this Window*)
{
    return this._maxHeight;
}

void set_MaxHeight(this Window*, int max_height)
{
    if (max_height > 0 && this._minHeight > 0)
        this._minHeight = Min(this._minHeight, max_height);
    this._maxHeight = max_height;
    UpdateWindowSize(this._id);
}
    
void Window::Focus()
{
    for (int i = 0; i < Game.GUICount; i++)
    {
        if (g_windows[i] != null)
        {
            g_windows[i].UnsetFocus();
        }
    }
    
    this._hasFocus = true;
    this.MoveToTop();
}

void WindowInternal::Init(int id)
{
    this._id = id;
    this._zsortPos = -1;
}

//===========================================================================
//
// WINDOW ACTIONS
//
//===========================================================================

void BeginResize(int win_id, int x, int y)
{
    ResetWindowDragState();
    
    GUI* g = gui[win_id];
    int gx = g.X;
    int gy = g.Y;
    int width = g.Width;
    int height = g.Height;
    
    WindowEdge edge = GetWindowEdge(win_id, x, y);
    if (edge == eWinEdgeNone)
    {
        return;
    }
    
    // The dragged pseudo-object position will be a position of a respective window edge or corner
    int dobj_x, dobj_y;
    switch (edge)
    {
    case eWinEdgeLeft:
    case eWinEdgeTopLeft:
    case eWinEdgeBottomLeft:
        dobj_x = gx;
        break;
    case eWinEdgeRight:
    case eWinEdgeTopRight:
    case eWinEdgeBottomRight:
        dobj_x = gx + width - 1;
        break;
    }
    
    switch (edge)
    {
    case eWinEdgeTop:
    case eWinEdgeTopLeft:
    case eWinEdgeTopRight:
        dobj_y = gy;
        break;
    case eWinEdgeBottom:
    case eWinEdgeBottomLeft:
    case eWinEdgeBottomRight:
        dobj_y = gy + height - 1;
        break;
    }
    
    g_winSystem.ResizingWindow = win_id;
    g_winSystem.ResizingWindowEdge = edge;
    DragDrop.HookObject(eDragWindow_Resize, dobj_x, dobj_y);
}

void BeginMove(int win_id, int x, int y)
{
    ResetWindowDragState();
    
    g_winSystem.DraggingWindow = win_id;
    DragDrop.HookObject(eDragWindow_Move, gui[win_id].X, gui[win_id].Y);
}

void DoMove()
{
    GUI* g = gui[g_winSystem.DraggingWindow];
    g.SetPosition(DragDrop.ObjectX, DragDrop.ObjectY);
}

void DoResize()
{
    GUI* g = gui[g_winSystem.ResizingWindow];
    int x = g.X;
    int y = g.Y;
    int width = g.Width;
    int height = g.Height;
    
    WindowEdge edge = g_winSystem.ResizingWindowEdge;
    switch (edge)
    {
    case eWinEdgeLeft:
    case eWinEdgeTopLeft:
    case eWinEdgeBottomLeft:
        width += x - DragDrop.ObjectX;
        x = DragDrop.ObjectX;
        break;
    case eWinEdgeRight:
    case eWinEdgeTopRight:
    case eWinEdgeBottomRight:
        width = DragDrop.ObjectX - x + 1;
        break;
    }
    
    switch (edge)
    {
    case eWinEdgeTop:
    case eWinEdgeTopLeft:
    case eWinEdgeTopRight:
        height += y - DragDrop.ObjectY;
        y = DragDrop.ObjectY;
        break;
    case eWinEdgeBottom:
    case eWinEdgeBottomLeft:
    case eWinEdgeBottomRight:
        height = DragDrop.ObjectY - y + 1;
        break;
    }
    
    SetWindowPosition2(g_winSystem.ResizingWindow, x, y, width, height);
}

void SetCursorForWindowEdge(WindowEdge edge)
{
    int cursor = g_winSystem.NormalCursor;
    switch (edge)
    {
    case eWinEdgeLeft:
    case eWinEdgeRight:
        cursor = g_winSystem.ResizeHorizontalCursor;
        break;
    case eWinEdgeTop:
    case eWinEdgeBottom:
        cursor = g_winSystem.ResizeVerticalCursor;
        break;
    case eWinEdgeTopLeft:
    case eWinEdgeTopRight:
    case eWinEdgeBottomLeft:
    case eWinEdgeBottomRight:
        cursor = g_winSystem.ResizeDiagonalCursor;
        break;
    }
    
    Mouse.Mode = cursor;
}

void SetCursorOverWindowEdge(int win_id, int x, int y)
{
    SetCursorForWindowEdge(GetWindowEdge(win_id, x, y));
}

//===========================================================================
//
// WINDOW GUI EXTENDERS
//
//===========================================================================

void AddToWindows(this GUI*, WindowStyle style)
{
    if (g_windows[this.ID] != null)
    {
        return;
    }
    
    g_windows[this.ID] = new WindowInternal;
    WindowInternal* window = g_windows[this.ID];
    window.Init(this.ID);
    window.Style = style;
    window.MaxWidth = -1;
    window.MaxHeight = -1;
    window.MinWidth = -1;
    window.MinHeight = -1;
    
    g_winSystem.WindowCount++;
    
    // New windows appear on top
    window.MoveToTop();
}

void RemoveFromWindows(this GUI*)
{
    if (g_windows[this.ID] == null)
    {
        return;
    }
    
    // Cancel any actions regarding this window
    if (g_winSystem.IsWindowAction)
    {
        DragDrop.Revert();
        ResetWindowDragState();
    }
    
    g_winSystem.WindowCount--;
    g_windows[this.ID] = null;
}

Window* GetWindow(this GUI*)
{
    return g_windows[this.ID];
}

function game_start()
{
    g_windows = new WindowInternal[Game.GUICount];
    g_winStack = new Window[Game.GUICount];
    
    // Default system setup
    g_winSystem.BorderWidth = 1;
    g_winSystem.CaptionHeight = 10;
    // Place windows behind "normal" guis by default
    g_winSystem.TopZ = -1000;
    g_winSystem.DraggingWindow = -1;
    g_winSystem.ResizingWindow = -1;
    
    DragDrop.Enabled = true;
    DragDrop.DefaultHookMouseButton = eMouseLeft;
    DragDrop.AutoTrackHookKey = true;
    DragDrop.DefaultUnhookAction = eDDUnhookDrop;
}

function late_repeatedly_execute_always()
{
    // Don't do anything when interface is disabled
    if (!IsInterfaceEnabled())
    {
        if (g_winSystem.WasInterfaceEnabled)
        {
            if (!DragDrop.IsIdle)
                DragDrop.Revert();
            ResetWindowDragState();
        }
        g_winSystem.WasInterfaceEnabled = false;
        return;
    }
    
    GUI* on_gui = GUI.GetAtScreenXY(mouse.x, mouse.y);
    Window *on_window;
    if (on_gui != null)
        on_window = g_windows[on_gui.ID];

    bool on_window_border, on_window_caption;
    if (on_window != null)
    {
        int x = mouse.x - on_gui.X;
        int y = mouse.y - on_gui.Y;
        if (x <= g_winSystem.BorderWidth || x >= on_gui.Width - g_winSystem.BorderWidth
            || y <= g_winSystem.BorderWidth || y >= on_gui.Height - g_winSystem.BorderWidth)
        {
            on_window_border = true;
            
        }
        else if (x > g_winSystem.BorderWidth && x < on_gui.Width - g_winSystem.BorderWidth
            && y > g_winSystem.BorderWidth && y < g_winSystem.BorderWidth + g_winSystem.CaptionHeight)
        {
            on_window_caption = true;
        }
    }
    
    // Test window activation
    bool mousedown[4];
    mousedown[eMouseLeft] = mouse.IsButtonDown(eMouseLeft);
    mousedown[eMouseRight] = mouse.IsButtonDown(eMouseRight);
    mousedown[eMouseMiddle] = mouse.IsButtonDown(eMouseMiddle);
    if (mousedown[eMouseLeft] && !g_winSystem.WasMouseButtonDown[eMouseLeft] ||
        mousedown[eMouseRight] && !g_winSystem.WasMouseButtonDown[eMouseRight] ||
        mousedown[eMouseMiddle] && !g_winSystem.WasMouseButtonDown[eMouseMiddle])
    {
        if (on_window != null && !on_window.get_HasFocus() &&
            !g_winSystem.IsWindowAction)
        {
            on_window.Focus();
        }
    }
    
    // If player is trying to drag something: check for a window under cursor
    // and decide whether to move or resize, depending on which part is being
    // interacted with.
    if (DragDrop.EvtWantObject)
    {
        if (on_window != null)
        {
            int x = mouse.x - on_gui.X;
            int y = mouse.y - on_gui.Y;
            if (on_window_border)
            {
                BeginResize(on_gui.ID, x, y);
            }
            else if (on_window_caption)
            {
                BeginMove(on_gui.ID, x, y);
            }
        }
    }
    
    // While player is dragging: update the current drag state
    if (DragDrop.HasObjectHooked)
    {
        if (g_winSystem.DraggingWindow >= 0)
        {
            DoMove();
        }
        else if (g_winSystem.ResizingWindow >= 0)
        {
            DoResize();
        }
    }
    
    if (DragDrop.EvtDropped || DragDrop.EvtCancelled)
    {
        ResetWindowDragState();
    }
    
    // Update cursor graphic
    if (DragDrop.HasObjectHooked)
    {
        if (g_winSystem.DraggingWindow >= 0)
        {
            Mouse.Mode = g_winSystem.DragCursor;
        }
        else if (g_winSystem.ResizingWindow >= 0)
        {
            SetCursorForWindowEdge(g_winSystem.ResizingWindowEdge);
        }
    }
    else
    {
        if (on_window_border)
        {
            SetCursorOverWindowEdge(on_gui.ID, mouse.x - on_gui.X, mouse.y - on_gui.Y);
        }
        else
        {
            Mouse.Mode = g_winSystem.NormalCursor;
        }
    }
    
    // Record current states
    g_winSystem.WasInterfaceEnabled = true;
    g_winSystem.WasMouseButtonDown[eMouseLeft] = mousedown[eMouseLeft];
    g_winSystem.WasMouseButtonDown[eMouseRight] = mousedown[eMouseRight];
    g_winSystem.WasMouseButtonDown[eMouseMiddle] = mousedown[eMouseMiddle];
}
